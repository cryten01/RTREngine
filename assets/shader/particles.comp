#version 430 core

/*
* The computeShader for updating particles using SIMD logic 
*/

// LAYOUTS //

layout (binding = 4, offset = 0) uniform atomic_uint particleCount;		// current particle count as atomic counter (because used simultaneously in every workgroup)

layout (local_size_x = 16, local_size_y = 16, local_size_y = 1) in;		// work group (grid of threads), gets a 16x16 workgroup from outside

layout(std430, binding = 0) buffer Pos1 {								// buffers (2x particlePos, 2x particleVel, duplicates because of ping-ponging)
	vec4 PosTTL_In[];
};
layout(std430, binding = 1) buffer Vel1 { 
	vec4 Velocity_In[];
};
layout(std430, binding = 2) buffer Pos2 {
	vec4 PosTTL_Out[];
};
layout(std430, binding = 3) buffer Vel2 {
	vec4 Velocity_Out[];
};


// PURE UNIFORMS AND CONSTANTS //

uniform float DeltaT;
uniform uint MaximumCount;
uniform uint LastCount;


// CONSTANTS //

const vec3 GRAVITY = vec3(0,0,0);


// METHODS //

void addParticleToOutputList(vec3 pos, vec3 vel, float TTL) { 

	// Increment the atomic counter and use its previous value
	uint particleIndex = atomicCounterIncrement(particleCount);	

	// Check if max particles is reached
	if (particleIndex >= MaximumCount) {
		atomicCounterDecrement(particleCount);
		return;
	}

	PosTTL_Out[particleIndex] = vec4(pos, TTL);	// set positionTTL for current particle
	Velocity_Out[particleIndex] = vec4(vel, 0);		// set velocity for current particle
}


void main() {

	// Unique one-dimensional index of workgroup
	uint idx = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;	

	// Bound check
	if (idx >= LastCount) return;

	// Receive position and velocity of particle from workgroup
	vec3 ParticlePos = vec3(PosTTL_In[idx].x, PosTTL_In[idx].y, PosTTL_In[idx].z);
	vec3 ParticleVel = vec3(Velocity_In[idx].x, Velocity_In[idx].y, Velocity_In[idx].z);

	// Update position
	float x = ParticlePos.x + (ParticleVel.x * DeltaT);
	float y = ParticlePos.y + (ParticleVel.y * DeltaT);
	float z = ParticlePos.z + (ParticleVel.z * DeltaT);
	ParticlePos = vec3(x,y,z);
	
	// Receive TTL from workgroup and update TimeToLive
	float TTL = PosTTL_In[idx].w - DeltaT;

	// Check if particle is still alive and add it to the output list
	if (TTL > 0) {		
		addParticleToOutputList(ParticlePos, ParticlePos, TTL);
	};
}